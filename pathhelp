using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Text.RegularExpressions;
using System.Collections;

namespace ConsoleApplication2
{
    internal static class StringEX
    {
        public const string boolean = "[@json:Intger='true']";
        public const string integer = "[@json:Boolean='true']";
        public const string array = "[@id=";

        internal static int GetIndex(this string str, char ch, int count)
        {
            int res = 0;
            for (int i = 0; i < count; i++)
            {
                res = str.IndexOf(ch, res) + 1;
            }
            return res + 1;
        }

        internal static bool IsArray(this string str)
        {
            return str.Contains(array);
        }
        internal static bool IsBoolean(this string str)
        {
            return str.Contains(boolean);
        }
        internal static bool IsInteger(this string str)
        {
            return str.Contains(integer);
        }
    }

    public class ClearSettings
    {
        public bool Arrays { get; set; }
        public bool Objects { get; set; }
    }

    internal interface IJNode
    {
        IJNode Parent { get; }
        bool HaveChildren { get; }
        string GetJson(string name);
        bool IsEmpty { get; }
        bool ShouldRemove(ClearSettings settings);
    }

    internal abstract class JNodeBase : IJNode
    {
        protected Dictionary<string, IJNode> children = new Dictionary<string, IJNode>();
        public bool HaveChildren { get { return children.Count > 0; } }
        public abstract bool ShouldRemove(ClearSettings settings);
        protected abstract char Close { get; }
        protected abstract string Open(string name);
        public virtual bool IsEmpty { get { return !HaveChildren; } }

        internal JNodeBase(IJNode parent)
        {
            Parent = parent;
        }
        public IJNode Parent { private set; get; }

        public IJNode Get(string key)
        {
            if (children.ContainsKey(key))
            {
                return children[key];
            }
            return null;
        }

        public virtual IJNode Add(string key, IJNode node)
        {
            if (!children.ContainsKey(key))
            {
                children[key] = node;
            }
            return children[key];
        }

        public virtual bool Remove(string key)
        {
            if (children.ContainsKey(key))
            {
                children.Remove(key);
                return true;
            }
            return false;
        }

        public bool Contains(string key)
        {
            return children.ContainsKey(key);
        }

        public void ClearEmpty(ClearSettings settings)
        {
            List<string> keysToRemove = new List<string>();
            foreach (var child in children)
            {
                if (child.Value.ShouldRemove(settings))
                {
                    keysToRemove.Add(child.Key);
                }
                else if (child.Value.HaveChildren)
                {
                    ((JNodeBase)child.Value).ClearEmpty(settings);
                }
            }
            foreach (var key in keysToRemove)
            {
                children.Remove(key);
            }
        }

        public string GetJson(string name)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(Open(name));
            foreach (var child in children)
            {
                sb.Append(child.Value.GetJson(child.Key) + ",");
            }
            if (HaveChildren)
                sb.Replace(',', Close, sb.Length - 1, 1);
            else
                sb.Append(Close);
            return sb.ToString();
        }
    }

    class JValue : IJNode
    {
        internal JValue(bool noQM, string value, IJNode parent)
        {
            this.value = value;
            this.noQM = noQM;
            Parent = parent;
        }
        string value;
        bool noQM;

        public Dictionary<string, IJNode> Children { get { return null; } }
        public bool HaveChildren { get { return false; } }
        public bool IsEmpty { get { return string.IsNullOrEmpty(value); } }

        public string GetJson(string name)
        {
            return Parent is JArray ?
                Value :
                $"\"{name}\": {Value}";
        }

        string Value { get { return noQM ? value : $"\"{value}\""; } }

        public IJNode Parent { private set; get; }

        public bool ShouldRemove(ClearSettings settings)
        {
            return IsEmpty;
        }
    }

    class JArray : JNodeBase
    {
        internal JArray(IJNode parent) : base(parent) { }

        protected override char Close { get { return ']'; } }

        public override bool ShouldRemove(ClearSettings settings)
        {
            return IsEmpty && settings.Arrays;
        }

        protected override string Open(string name) { return $"\"{name}\": ["; }
    }

    class JObject : JNodeBase
    {
        internal JObject(IJNode parent) : base(parent) { }

        protected override char Close { get { return '}'; } }

        public override bool ShouldRemove(ClearSettings settings)
        {
            return IsEmpty && settings.Objects;
        }

        protected override string Open(string name)
        {
            return Parent is JArray ?
                "{" :
                $"\"{name}\": {{";
        }
    }

    class JRoot : JNodeBase
    {
        internal JRoot(List<pathy> xPathList) : base(null)
        {
            foreach (var path in xPathList)
            {
                string[] splitedPath = path.path.Split('/');
                AddPath(splitedPath, path.value);
            }
        }

        void AddPath(string[] splitedPath, string value)
        {
            JNodeBase c = this;
            for (int i = 0; i < splitedPath.Length - 1; i++)
            {
                if (string.IsNullOrEmpty(splitedPath[i]))
                    continue;
                else
                {
                    c = AddObjectNode(splitedPath[i], c);
                }
            }
            AddValueNode(splitedPath[splitedPath.Length - 1], c, value);
        }

        JNodeBase AddObjectNode(string name, JNodeBase parent)
        {
            if (name.IsArray())
            {
                string childName;
                JArray array = AddArrayElement(parent, name, out childName);
                return AddObjectNode(childName, array);
            }
            else
            {
                return (JNodeBase)parent.Add(name, new JObject(parent));
            }

        }

        void AddValueNode(string name, JNodeBase parent, string value)
        {
            bool noQM = false;
            if (name.IsArray())
            {
                string childName;
                JArray array = AddArrayElement(parent, name, out childName);
                AddValueNode(childName, array, value);
            }
            else
            {
                if (name.IsInteger() || name.IsBoolean())
                {
                    noQM = true;
                    name = name.Substring(0, name.IndexOf('['));
                }
                value = value.Replace("\"", "\\\"");
                parent.Add(name, new JValue(noQM, value, parent));
            }
        }

        JArray AddArrayElement(JNodeBase parent,string name,out string childName)
        {
            int start = name.IndexOf('[');
            int end = name.IndexOf(']');
            string arrayName = name.Substring(0, start);

            childName =      
                name.Substring(start + 6, end - (start + 6)) +
                name.Substring(end+1) ;
            return (JArray)parent.Add(arrayName, new JArray(parent));
        }

        public void Add(string[] splitedPath, string value)
        {
            AddPath(splitedPath, value);
        }

        public JNodeBase Get(string[] splitedPath)
        {
            JNodeBase c = this;
            for (int i = 0; i < splitedPath.Length - 1; i++)
            {
                if (c != null && c.Contains(splitedPath[i]))
                {
                    c = c.Get(splitedPath[i]) as JNodeBase;
                }
                else
                {
                    return null;
                }
            }
            return c;
        }

        public bool Remove(string[] splitedPath)
        {
            JNodeBase c = Get(splitedPath);
            if (c != null && c.Contains(splitedPath[splitedPath.Length - 1]))
            {
                c.Remove(splitedPath[splitedPath.Length - 1]);
                return true;
            }
            return false;
        }

        public string GetJson(bool noRoot = true)
        {
            var result = GetJson(string.Empty);
            int start = noRoot ? result.GetIndex('"', 2) : 0;
            int end = noRoot ? 1 : 0;
            return result.Substring(start, result.Length - start - end);
        }

        protected override char Close { get { return '}'; } }

        protected override string Open(string name) { return "{"; }

        public override bool ShouldRemove(ClearSettings settings)
        {
            return false;
        }
    }

    public class PathToJson
    {
        JRoot root;
        public ClearSettings ClearSettings { get; set; }

        public PathToJson(List<pathy> paths)
        {
            root = new JRoot(paths);
            ClearSettings = new ClearSettings();
        }

        public void Add(string path, string value)
        {
            root.Add(path.Split('.'), value);
        }

        public bool Remove(string path)
        {
            return root.Remove(path.Split('.'));
        }

        public bool Contains(string path)
        {
            string[] splitedPath = path.Split('.');
            var node =root.Get(splitedPath);
            if (node != null)
                return node.Contains(splitedPath[splitedPath.Length - 1]);
            return  false;
        }

        public string GetJson(bool noRoot = true)
        {
            return root.GetJson(noRoot);
        }

        public void ClearEmpty()
        {
            root.ClearEmpty(ClearSettings);
        }
    }

    public class pathy
    {
        public string path;
        public string value;
    }

    class Class1
    {
        static List<pathy> paths = new List<pathy>(){
                       new pathy() { path = @"a/ar/a[@id='2]/g[@json:Intger='true']" ,value = "2"},
            new pathy() {path=@"a/b" ,value="heloo"},
            new pathy() {path=@"a/c" ,value="world"},
            new pathy() {path=@"a/d/e[@json:Intger='true']" ,value="5"},
        new pathy() {path=@"a/d/f" ,value="deep"},
        new pathy() {path=@"a/d/a" ,value="deep2"},
        new pathy() {path=@"a/n/j[@json:Intger='true']" ,value="false"},
        new pathy() {path=@"a/v[@json:Intger='true']" ,value="true"},
        new pathy() { path = @"a/ar/a[@id='1]/g[@json:Intger='true']" ,value = "1"},
         new pathy() { path = @"a/ya[@id='1]" ,value = "1"},
                  new pathy() { path = @"a/ya[@id='2][@json:Intger='true']" ,value = "8"},
                               new pathy() { path = @"a/ya[@id='3]/j[@json:Intger='true']" ,value = "1"},
        };
        public static void Test()
        {
            PathToJson root = new PathToJson(paths);
            root.Add("a.y.y.y[json:Intger='true']", "true");
           var k = root.Contains("a");
            var k2 = root.Contains("a");
            var t = root.Contains("j");
            root.Remove("a.y.y");
            root.Remove("a.ya.2");
            root.Remove("a.ya.2");
            root.Remove("a.ya.2");
            root.ClearSettings.Arrays = false;
            root.ClearSettings.Objects = false;
            root.ClearEmpty();
            /* root.Remove("a.ar.a.'2]");
             root.Remove("a.ar");
             root.Remove("a.d");*/
            Console.WriteLine(root.GetJson(false));

        }


    }
}
